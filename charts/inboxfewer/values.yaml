replicaCount: 1

image:
  repository: ghcr.io/teemow/inboxfewer
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  # Set to false as the app doesn't need Kubernetes API access
  automount: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: inboxfewer.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: inboxfewer-tls
  #    hosts:
  #      - inboxfewer.local

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

livenessProbe:
  enabled: true
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  enabled: true
  httpGet:
    path: /readyz
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Pod disruption budget for controlled disruptions
podDisruptionBudget:
  enabled: false
  maxUnavailable: 1

# Additional volumes on the output Deployment definition.
volumes:
  # Cache directory for OAuth tokens and application cache
  # Using emptyDir allows writes with readOnlyRootFilesystem: true
  # Tokens are lost on pod restart, requiring re-authentication
  - name: cache
    emptyDir: {}
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
  # Mount writable cache directory for OAuth tokens
  - name: cache
    mountPath: /home/inboxfewer/.cache
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

# Application configuration
config:
  # Transport type: stdio or streamable-http
  transport: "streamable-http"
  # HTTP server address
  httpAddr: ":8080"
  # Public base URL for OAuth (required for deployed instances)
  # Example: "https://inboxfewer.example.com"
  # If not set, auto-detected as http://localhost:8080 (development only)
  baseURL: ""
  # Enable write operations (default: false for read-only mode)
  yolo: false
  # Enable debug logging
  debug: false
  # Disable streaming for HTTP transport
  disableStreaming: false

# Google OAuth configuration
google:
  # Google OAuth Client ID for automatic token refresh
  # Set via environment variable or secret
  clientId: ""
  # Google OAuth Client Secret for automatic token refresh
  # Set via environment variable or secret
  clientSecret: ""

# OAuth Security Settings (secure by default)
# Only modify these if you understand the security implications
oauthSecurity:
  # Allow unauthenticated dynamic client registration
  # WARNING: Setting to true weakens security and enables DoS attacks
  # Default: false (requires registration access token)
  allowPublicClientRegistration: false
  
  # Registration access token required for client registration
  # Only used if allowPublicClientRegistration is false
  # Generate a secure random token (e.g., openssl rand -base64 32)
  registrationAccessToken: ""
  
  # AES-256 encryption key for token storage at rest (32 bytes, base64 encoded)
  # REQUIRED for production deployments
  # Generate with: openssl rand -base64 32
  # If not set, tokens are stored unencrypted in memory (development only)
  encryptionKey: ""
  
  # Allow authorization without state parameter
  # WARNING: Setting to true weakens CSRF protection
  # Default: false (state parameter required)
  allowInsecureAuthWithoutState: false
  
  # Maximum number of clients that can be registered per IP address
  # Prevents DoS attacks via mass client registration
  # Default: 10
  maxClientsPerIP: 10

  # Redirect URI Security Configuration (mcp-oauth v0.2.30+)
  # All settings default to secure values. Use disable* to opt-out.
  redirectURISecurity:
    # Disable production mode security validation
    # Production mode enforces: HTTPS required, private IPs blocked, dangerous schemes blocked
    # WARNING: Significantly weakens redirect URI security. Only disable for development.
    # Default: false (production mode is enabled)
    disableProductionMode: false

    # Allow http://localhost and http://127.0.0.1 redirect URIs
    # Required for native apps per RFC 8252 Section 7.3
    # Default: false (operators must explicitly enable for native app support)
    allowLocalhostRedirectURIs: false

    # Allow private IP addresses (10.x, 172.16.x, 192.168.x) in redirect URIs
    # WARNING: Enables SSRF attacks to internal networks if not properly secured.
    # Only enable for internal/VPN deployments where clients use private IPs.
    # Default: false (blocked for security)
    allowPrivateIPRedirectURIs: false

    # Allow link-local addresses (169.254.x.x, fe80::/10) in redirect URIs
    # WARNING: Could enable access to cloud metadata services (169.254.169.254).
    # This is a significant security risk in AWS, GCP, Azure environments.
    # Default: false (blocked for security)
    allowLinkLocalRedirectURIs: false

    # Disable DNS validation of redirect URI hostnames
    # DNS validation checks if hostnames resolve to private/internal IPs.
    # WARNING: Disabling allows potential DNS rebinding attacks.
    # Default: false (DNS validation is enabled)
    disableDNSValidation: false

    # Disable fail-closed DNS validation
    # When strict mode is enabled, DNS resolution failures block client registration.
    # When disabled, DNS failures are logged but registration proceeds (fail-open).
    # WARNING: Disabling allows potential DNS validation bypass via intentional failures.
    # Default: false (strict mode is enabled)
    disableDNSValidationStrict: false

    # Disable redirect URI validation at authorization time
    # By default, redirect URIs are re-validated during authorization requests,
    # not just at registration time. This protects against TOCTOU attacks.
    # WARNING: Disabling allows DNS rebinding attacks between registration and use.
    # Default: false (authorization-time validation is enabled)
    disableAuthorizationTimeValidation: false

  # Trusted Scheme Registration for Cursor/VSCode Compatibility (mcp-oauth v0.2.30+)
  # This feature allows unauthenticated client registration for clients using
  # specific custom URI schemes (e.g., cursor://, vscode://), while requiring
  # registration tokens for all other clients.
  #
  # Security Model:
  # Custom URI schemes can only be intercepted by the application that registered
  # the scheme with the OS. An attacker cannot register a malicious OAuth client
  # with cursor:// because they cannot receive the authorization callback.
  #
  # Example: ["cursor", "vscode", "vscode-insiders", "windsurf"]
  # Default: [] (all registrations require a token)
  trustedPublicRegistrationSchemes: []

  # Disable strict scheme matching for trusted scheme registration
  # When strict matching is enabled (default), ALL redirect URIs in a registration
  # request must use schemes from trustedPublicRegistrationSchemes.
  # When disabled, if ANY redirect URI uses a trusted scheme, registration is allowed.
  # WARNING: Reduces security by allowing untrusted redirect URIs alongside trusted ones.
  # Default: false (strict matching is enabled)
  disableStrictSchemeMatching: false

  # Client ID Metadata Documents (CIMD) - MCP 2025-11-25 (mcp-oauth v0.2.30+)
  # When enabled, clients can use HTTPS URLs as client identifiers (e.g.,
  # https://myapp.example.com/.well-known/oauth-client). The authorization server
  # fetches client metadata from that URL, enabling decentralized client registration.
  #
  # Security: CIMD requires the server to make outbound HTTPS requests. The mcp-oauth
  # library implements comprehensive SSRF protection (blocks private IPs, DNS rebinding).
  #
  # Default: true (enabled per MCP 2025-11-25 specification)
  enableCIMD: true

  # Token storage configuration (mcp-oauth v0.2.30+)
  # In-memory storage is default but NOT recommended for production
  # Use Valkey for production deployments to enable:
  #   - Session persistence across pod restarts
  #   - Horizontal scaling with shared session state
  #   - Rolling updates without user session loss
  storage:
    # Storage backend type: "memory" or "valkey"
    # Default: "memory" (NOT recommended for production)
    type: "memory"

    # Valkey (Redis-compatible) storage configuration
    # Required when storage.type is "valkey"
    valkey:
      # Valkey server URL (e.g., "valkey.namespace.svc:6379")
      # Required when using Valkey storage
      url: ""

      # Enable TLS for Valkey connections
      # Recommended for production
      tls:
        enabled: false

      # Key prefix for all Valkey keys
      # Useful for multi-tenant deployments sharing a Valkey instance
      keyPrefix: "mcp:"

      # Valkey database number (0-15)
      db: 0

      # Use an existing secret for Valkey password
      # The secret should contain key: valkey-password
      existingSecret: ""

      # Key in the secret containing the Valkey password
      secretKeyPassword: "valkey-password"

# TLS/HTTPS Configuration
# Native HTTPS support without reverse proxy
tls:
  # Enable native TLS/HTTPS
  enabled: false

  # TLS certificate and key can be provided via:
  # 1. Existing secret reference (recommended for production)
  # 2. Inline values (not recommended, use secrets instead)

  # Existing secret containing TLS certificate and key
  # The secret should contain keys: tls.crt, tls.key
  existingSecret: ""

  # Path where TLS files will be mounted (if using existingSecret)
  # Default: /etc/tls
  mountPath: "/etc/tls"

# OAuth Interstitial Page Branding
# Customize the success page shown after OAuth authentication for custom URL schemes
# (cursor://, vscode://, etc.). If not set, uses the mcp-oauth default styling.
interstitial:
  # Logo URL displayed on the success page (must be HTTPS)
  # Example: "https://raw.githubusercontent.com/teemow/inboxfewer/main/assets/logo/logo-512.png"
  logoURL: ""
  # Alt text for the logo image (for accessibility)
  # Example: "inboxfewer logo"
  logoAlt: ""
  # Title displayed on the success page
  # Example: "Connected to Inboxfewer"
  title: ""
  # Message shown below the title
  # Use {{.AppName}} placeholder for the app name
  # Example: "You have been authenticated with {{.AppName}}. You can now close this window."
  message: ""
  # Button text for manual redirect
  # Use {{.AppName}} placeholder for the app name
  # Example: "Return to {{.AppName}}"
  buttonText: ""
  # Primary/accent color for buttons (CSS color value)
  # Example: "#667eea"
  primaryColor: ""
  # Background gradient CSS value
  # Example: "linear-gradient(135deg, #1e3a5f 0%, #2d5a87 100%)"
  backgroundGradient: ""

# Existing secret containing Google OAuth credentials
# Keys should be: google-client-id, google-client-secret
# Optionally: oauth-registration-token, oauth-encryption-key
existingSecret: ""

# GitHub configuration (required for cleanup command)
github:
  # GitHub username
  user: ""
  # GitHub token
  token: ""

# Existing secret containing GitHub credentials
# Keys should be: github-user, github-token
githubSecret: ""

# Network policies for defense-in-depth security
networkPolicy:
  # Enable NetworkPolicy for controlling pod network access
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  # Ingress rules - who can connect to this pod
  ingress:
    - from:
      # Allow ingress from pods with specific labels
      - podSelector:
          matchLabels:
            app: allowed-client
      # Allow ingress from specific namespaces
      # - namespaceSelector:
      #     matchLabels:
      #       name: allowed-namespace
      ports:
      - protocol: TCP
        port: 8080
  # Egress rules - where this pod can connect to
  egress:
    # Allow HTTPS to external APIs (Google, GitHub)
    - to:
      - namespaceSelector: {}
      ports:
      - protocol: TCP
        port: 443
    # Allow DNS queries
    - to:
      - namespaceSelector:
          matchLabels:
            name: kube-system
      - podSelector:
          matchLabels:
            k8s-app: kube-dns
      ports:
      - protocol: UDP
        port: 53



# Cilium Network Policy configuration
# More advanced network policy for Cilium users
ciliumNetworkPolicy:
  # Enable CiliumNetworkPolicy for enhanced network control
  enabled: false
  # Additional labels to add to the CiliumNetworkPolicy
  labels: {}
  # Additional annotations to add to the CiliumNetworkPolicy
  annotations: {}

# ServiceMonitor for Prometheus Operator
# Note: Requires metrics endpoint to be enabled (future feature)
serviceMonitor:
  # Enable ServiceMonitor creation (requires Prometheus Operator CRDs)
  enabled: false
  # Additional labels for the ServiceMonitor (e.g., for Prometheus selection)
  labels: {}
  # Additional annotations for the ServiceMonitor
  annotations: {}
  # Scrape interval (default: Prometheus default)
  interval: ""
  # Scrape timeout (default: Prometheus default)
  scrapeTimeout: ""
  # Relabelings for the ServiceMonitor
  relabelings: []
  # Metric relabelings for the ServiceMonitor
  metricRelabelings: []
