---
description: Guide for using Task Master to manage task-driven development workflows
globs: **/*
alwaysApply: true
---

# The Development Workflow

This document outlines the standard, iterative process for all development work. Following this workflow is **mandatory** to ensure consistency, quality, and effective collaboration across the project.

## The Core Development Loop

All work, from new features to bug fixes, follows this fundamental three-phase cycle:

**‚ö†Ô∏è REMEMBER: This repository uses `main` as the default branch. NEVER commit directly to `main`!**

1.  **Phase 1: Planning & Alignment**
    -   Select an issue from the backlog.
    -   **Create a dedicated feature branch from `main`** (NEVER work directly on `main`).
    -   Explore the codebase to create a detailed implementation strategy.

2.  **Phase 2: Iterative Implementation**
    -   **Log your plan first.** Document your intended changes in the relevant task *before* writing code.
    -   Implement the changes, adhering to the project's architectural guidelines.
    -   Continuously log progress, discoveries, and setbacks as you work to create a rich history of the task.

3.  **Phase 3: Finalization & Committing**
    -   Write and pass all required tests.
    -   Format your code according to project standards.
    -   Update any relevant project rules based on your changes.
    -   Commit your work using a structured, conventional commit message.
    -   Close the corresponding issue.

---

## Phase 1: Planning & Alignment

Before writing a single line of implementation code, you must have a clear plan and be working on the correct branch.

### 1.1. Select an Issue & State Your Intent

1.  **List Open Issues:** Use `mcp_github_list_issues` to see available tasks for `teemow/inboxfewer`.
2.  **Choose an Issue:** Select the highest-priority issue you are able to work on.
3.  **Get Details:** Use `mcp_github_get_issue` to retrieve its full details.
4.  **Announce Your Plan:** In the chat, you **MUST** summarize the issue (title, number) and your intended high-level approach.
    -   **Example:** *"I am starting work on issue #37: Refactor Capability API. My plan is to start by defining the new interfaces in the API package..."*

### 1.2. Create a Dedicated Git Branch

**üö® CRITICAL: NEVER COMMIT DIRECTLY TO THE `main` BRANCH! üö®**

The repository uses `main` as the default branch (NOT `master`). All work MUST be done in feature branches.

1.  **Check Your Current Branch:** Run `git rev-parse --abbrev-ref HEAD`.
2.  **STOP if on `main`:** If you are on `main`, you MUST create a new branch immediately. DO NOT make any commits to `main`.
3.  **Branch Naming Convention:** Branch names **MUST** follow this format:
    > `<type>/issue-<number>-<kebab-case-title>`
4.  **Branch Types:** `feature`, `fix`, `refactor`, `docs`, `test`, `chore`.
5.  **Example:** `git checkout -b feature/issue-42-add-prometheus-provider`

**Workflow Summary:**
- ‚úÖ Always create a branch from `main`
- ‚úÖ Make all commits to your feature branch
- ‚úÖ Push your branch and create a Pull Request
- ‚úÖ Merge to `main` only via Pull Request
- ‚ùå NEVER `git commit` while on `main`
- ‚ùå NEVER `git push origin main`

### 1.3. Explore and Plan

This is a critical step to ensure your implementation is well-considered.

1.  **Explore the Codebase:** Identify the specific files, functions, and lines of code that need to be added, removed, or changed.
2.  **Formulate a Detailed Plan:** Based on your exploration, create a precise implementation plan. What is the exact diff you intend to apply? What potential challenges do you foresee? This plan will be logged in the next step.

---

## Phase 2: Iterative Implementation & Logging

This cycle is the heart of the workflow. It's designed to build a rich, contextual history of the implementation, which is invaluable for debugging, collaboration, and future reference.

### 2.1. Log Your Plan *Before* Coding

1.  Before you start implementing, log the detailed plan you created in step 1.3.
2.  Always update the description of the existing issue with your plan
3.  Verify that the plan was successfully logged by viewing the issue details again.

### 2.2. Implement & Log Progress

1.  **Set Issue Status:** Mark the issue as `in-progress`
2.  **Write Code:** Begin writing code according to your plan and the project's [architecture.mdc](mdc:.cursor/rules/architecture.mdc).
3.  **Log Continuously:** As you work, you will learn things. **You must log them.** Regularly update the issue to append new findings.
    -   ‚úÖ **What Worked:** Confirmed approaches, "fundamental truths."
    -   ‚ùå **What Didn't Work:** Dead ends, failed experiments, and why.
    -   ‚öôÔ∏è **Specifics:** Successful code snippets, configurations, or commands.
    -   üó£Ô∏è **Decisions:** Any choices made, especially if confirmed with the user.

---

## Phase 3: Finalization & Committing

### 3.1. Pre-Commit Quality Check

Before **every** commit, you **MUST** perform these checks:

1.  **Format Code:**
    ```bash
    goimports -w .
    go fmt ./...
    ```
2.  **Run All Tests:**
    ```bash
    make test
    ```
    -   **DO NOT** commit if any tests are failing. Fix the tests first.
    -   Code must meet the test coverage minimums defined in [architecture.mdc](mdc:.cursor/rules/architecture.mdc).

### 3.2. Review & Update Rules

1.  Review your implementation and the chat history.
2.  Identify any new patterns, conventions, or best practices that emerged.
3.  Update existing rules or create new ones, following the guidelines in [cursor_rules.mdc](mdc:.cursor/rules/cursor_rules.mdc). This is a critical step for our collective improvement.

### 3.3. Craft the Commit Message

Commit messages are vital documentation. They **MUST** follow the [Conventional Commits](mdc:https:/www.conventionalcommits.org/en/v1.0.0) specification.

**Structure:**
```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```
-   **Type:** `feat`, `fix`, `refactor`, `docs`, `test`, `chore`, `style`, `perf`, `ci`, `build`.
-   **Scope (Optional):** The area of the codebase affected (e.g., `api`, `tui`, `capability`).
-   **Subject:** A short, imperative-tense summary. No period at the end.
-   **Body (Recommended):** Explain the *what* and *why* of the change.
-   **Footer:** Reference the issue being closed using `Closes #<issue_number>`. This automatically links the commit to the issue and closes it. Include `BREAKING CHANGE:` for any backward-incompatible changes.

**Example:**
```
feat(api): Add GetWorkflow handler

Implement the GetWorkflow function in the API layer to allow services
to retrieve workflow definitions by name. This is a prerequisite
for the workflow execution engine.

Closes #52
```

### 3.4. Commit, Push, and Create Pull Request

**‚ö†Ô∏è VERIFICATION: Before committing, ensure you are NOT on the `main` branch!**

1.  **Verify Branch:** Run `git branch --show-current` - it MUST NOT be `main`
2.  **Commit Changes:**
    ```bash
    git add .
    git commit -m "..."
    ```
3.  **Never Amend Commits**: Amend is very difficult to handle with multiple people and with gitops. So avoid using this.
4.  **Push Branch:**
    ```bash
    git push -u origin <your-branch-name>
    ```
5.  **Create Pull Request:** Use `gh pr create` to create a PR targeting the `main` branch
6.  **Mark Issue Done:** Set the task status to `done`.
7.  **Announce Completion:** Inform the user that your changes have been pushed to a branch and a PR has been created.

---

## Phase 4: Test Deployments (Optional)

For features that require testing in a live environment before merging, you can deploy feature branches to a test cluster.

**‚ö†Ô∏è IMPORTANT: This repository is PUBLIC. Never commit cluster-specific configuration here.**

### 4.1. Automatic Artifact Building

When you create a Pull Request, GitHub Actions automatically builds and publishes:

1. **Docker Images**: Tagged with the PR merge commit SHA
2. **Helm Charts**: Tagged with the PR merge commit SHA

These artifacts are published to the GitHub Container Registry (ghcr.io).

### 4.2. Finding Published Artifact Versions

After pushing to your feature branch and creating a PR, GitHub Actions will build the artifacts:

```bash
# List recent workflow runs for your branch
gh run list --branch <your-branch-name> --limit 5

# View a specific workflow run
gh run view <run-id>

# Check the Helm chart release logs to find the published version
gh run view <helm-release-run-id> --log | grep "Chart:"
```

**Important:** GitHub Actions uses a temporary merge commit SHA when testing PRs. The published chart version will use this merge commit SHA, not your branch commit SHA.

**Artifact naming pattern:**
- Docker Image: `ghcr.io/teemow/inboxfewer:0.1.1-refs-pull-<PR#>-merge-<merge-commit-sha>`
- Helm Chart: `ghcr.io/teemow/charts/inboxfewer:0.1.1-refs-pull-<PR#>-merge-<merge-commit-sha>`

Example:
```
ghcr.io/teemow/charts/inboxfewer:0.1.1-refs-pull-56-merge-2d7d5eb6d373cc64bad752ae2713abfb8290ea4a
```

### 4.3. Deploying to a Test Cluster

**Deployment configurations are managed in a separate, private GitOps repository.** This keeps sensitive cluster information (like ingress domains, secrets, and infrastructure details) out of this public repository.

#### General Deployment Process:

1. **Locate the HelmRelease configuration** in your GitOps repository
   - Typically found under a path like `cluster/apps/<app-name>/release.yaml`

2. **Update the Helm chart version** to use the PR artifact:
   ```yaml
   spec:
     chart:
       spec:
         chart: inboxfewer
         version: '0.1.1-refs-pull-56-merge-<merge-commit-sha>'
         sourceRef:
           kind: HelmRepository
           name: inboxfewer
           namespace: flux-system
   ```

3. **Force pod restart** (optional but recommended):
   - Add or update a pod annotation to force a restart and image pull:
   ```yaml
   spec:
     values:
       podAnnotations:
         rollme: "2025-11-23-01-40"  # Use current timestamp
   ```

4. **Commit and push** the deployment configuration changes to your GitOps repository

5. **Reconcile Flux** to deploy the changes:
   ```bash
   # Reconcile the GitRepository and Kustomization
   flux reconcile source git flux-system
   flux reconcile kustomization flux-system
   
   # Reconcile the specific HelmRelease
   flux reconcile helmrelease -n <namespace> <release-name>
   ```

6. **Verify the deployment**:
   ```bash
   # Check HelmRelease status
   flux get helmreleases -n <namespace> <release-name>
   
   # Check pod status
   kubectl -n <namespace> get pods
   
   # Wait for rollout
   kubectl -n <namespace> rollout status deployment/<deployment-name>
   
   # Check logs
   kubectl -n <namespace> logs deployment/<deployment-name>
   ```

### 4.4. Testing and Iteration

Once deployed:

1. **Test your changes** in the live environment
2. **Check logs** for any errors or unexpected behavior
3. **Iterate** if needed:
   - Make code changes in your feature branch
   - Push the changes
   - Wait for new artifacts to be built
   - Update the deployment configuration with the new artifact version
   - Reconcile Flux again

### 4.5. Cleanup After Testing

After your testing is complete and the PR is merged:

1. **Revert the test deployment configuration** in your GitOps repository
2. **Deploy the official release** (merged to main) if appropriate

### 4.6. Security Considerations

- ‚úÖ **DO:** Keep all cluster-specific configuration in a private GitOps repository
- ‚úÖ **DO:** Use Kubernetes secrets for sensitive data (OAuth credentials, API keys, etc.)
- ‚úÖ **DO:** Encrypt secrets with tools like SOPS before committing to Git
- ‚ùå **DON'T:** Commit cluster URLs, domains, or network topology to public repositories
- ‚ùå **DON'T:** Commit credentials or secrets to any Git repository (even private ones without encryption)
- ‚ùå **DON'T:** Include deployment configuration in this public repository
